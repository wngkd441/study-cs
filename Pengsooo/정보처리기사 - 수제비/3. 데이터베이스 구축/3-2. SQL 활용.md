## Ch2. SQL 활용

### (1) 기본 SQL 작성

#### 1. 데이터 정의어(DDL)

**데이터 정의어(Data Definition Language)** 는 데이터를 정의하는 언어로서 데이터를 담는 그릇을 정의하는 언어이다.

- 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어.
- 특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들.



- 대상<span style="color:blue">*VV*</span>

  |    DDL 대상     | 설명                                                         |
  | :-------------: | :----------------------------------------------------------- |
  | 도메인(Domatin) | 하나의 속성이 가질 수 있는 원자값들의 집합<br />속성의 데이터 타입과 크기, 제약조건 등의 정보 |
  | 스키마(Schema)  | 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조<br />1. 외부 스키마(External Schema)<br />    사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조<br />    사용자 뷰를 나타냄, 서브 스키마라고도 불림.<br />2. 개념 스키마(Conceptual Schema)<br />    데이터베이스의 전체적인 논리적 구조<br />    전체적인 뷰를 나타냄.<br />3. 내부 스키마(Internal Schema)<br />    물리적 저장장치의 관점에서 보는 데이터베이스 구조<br />    실제로 데이터베이스에 저장될 레코드의 형식을 정의<br />    저장 데이터 항목의 표현 방법 |
  |  테이블(Table)  | 데이터 저장 공간                                             |
  |    뷰(View)     | 하나 이상의 물리 테이블에서 유도되는 가상의 테이블           |
  |  인덱스(Index)  | 검색을 빠르게 하기 위한 데이터 구조                          |

  

- 명령어 <span style="color:blue">*VVVVVVV*</span>

- | 구분 | DDL 명령어 | 설명                            |
  | :--: | :--------: | :------------------------------ |
  | 생성 |   CREATE   | 데이터베이스 오브젝트 생성      |
  | 수정 |   ALTER    | 데이터베이스 오브젝트 변경      |
  | 삭제 |    DROP    | 데이터베이스 오브젝트 삭제      |
  | 삭제 |  TRUNCATE  | 데이터베이스 오브젝트 내용 삭제 |

  - CREATE 명령어

    - 문법

      ```SQL
      CREATE TABLE 테이블명
      (
      	속성명 데이터타입 [NOT NULL], ...,
      	PRIMARY KEY(기본키),
      	UNIQUE(속성명, ...),
      	FOREIGN KEY(외래키) REFERNECES 참조테이블(기본키),
      	CONSTRAINT 제약조건명 CHECK(조건식)
      );
      ```

    - 속성

      |    속성     | 설명                                                         |
      | :---------: | :----------------------------------------------------------- |
      | PRIMARY KEY | 테이블의 기본 키를 정의<br />유일하게 테이블의 각 행을 식별  |
      | FOREIGN KEY | 외래 키를 정의<br />참조 대상을 테이블(컬럼명)로 명시        |
      |   UNIQUE    | 테이블 내에서 얻은 유일한 값을 갖도록 하는 속성              |
      |  NOT NULL   | 해당 컬럼은 NULL 값을 포함하지 않도록 하는 속성              |
      |    CHECK    | 개발자가 정의하는 제약조건<br />참(TRUE)이어야 하는 조건을 지정 |
      |   DEFAULT   | 해당 필드의 기본값을 설정                                    |

  - ALTER 명령어

    |    구분     |                             문법                             | 설명                                                         |
    | :---------: | :----------------------------------------------------------: | :----------------------------------------------------------- |
    |  컬럼 추가  |        ALTER TABLE 테이블명 ADD 컬럼명 데이터\_타입;         | 테이블에 필요한 컬럼을 추가하는 명령어                       |
    |  컬럼 수정  | ALTER TABLE 테이블명 MODIFY 컬럼명 데이터\_타입 [DEFAULT 값] [NOT NULL]; | 기존 테이블에 존재하는 컬럼의 데이터 유형, 기본값, NOT NULL등의 제약조건에 대한 변경 |
    |  컬럼 삭제  |              ALTER TABLE 테이블명 DROP 컬럼명;               | 테이블에 존재하는 컬럼을 삭제하는 명령어                     |
    | 컬럼명 수정 | ALTER TABLE 테이블명 RENAME COLUMN 변경 전\_컬럼명 TO 변경 후\_컬럼명; | 테이블의 컬럼명을 변경하는 명령어                            |

    - 예시

      ```SQL
      ALTER TABLE 사원 ADD 나이 INTEGER DEFAULT 20;
      ```

    - 속성

      CREATE TABLE의 속성에 사용되는 제약조건들을 ALTER TABLE에서도 사용할 수 있다.

  - DROP 명령어

    - 문법

      ```SQL
      DROP TABLE 테이블명 [CASCADE | RESTRICT];
      ```

    - 명령어 옵션 <span style="color:blue">*VVV*</span>

      |   옵션   | 설명                                                         |
      | :------: | :----------------------------------------------------------- |
      | CASCADE  | 참조하는 테이블까지 연쇄적으로 제거하는 옵션                 |
      | RESTRICT | 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션 |

  - TRUNCATE 명령어

    - 예시

      ```SQL
      TRUNCATE TABLE 테이블명;
      ```





#### 2. 관계형 데이터 모델

**관계형 데이터 모델(Relation Data Model)** 은 보편적인 데이터 모델로, 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델이다.

- 대표적 언어로 SQL이 있다.

- 데이터 간의 관계를 기본 키와 이름 참조하는 외래 키로 표현한다.

- 테이블 간 관계를 1:1, 1:N, M:N 관계로 목적에 맞게 표현한다.

  

- 표현 예시

  ![관계형 데이터 모델](http://ehpub.co.kr/wp-content/uploads/2016/12/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8.png)

  - 고객 테이블, 예약 테이블, 예약서 테이블을 관계 데이터 모델로 표현.
  - 고객 테이블의 Primary Key는 번호, 예약서 테이블의 Primary Key는 예약 번호.
  - 고객 테이블과 예약 테이블은 1:N 관계, 예약 테이블과 예약서 테이블은 1:1 관계.
  - 이미지 출처 - [언제나 휴일 프로그래머 블로그 - 17. 관계 데이터 모델](https://ehpub.co.kr/17-%EA%B4%80%EA%B3%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8/)





#### 3. 트랜잭션

**트랜잭션(Transaction)** 은 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위이다.

- 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성.

  

- 특징 <span style="color:blue">*VVVVVVVVVVV*</span>

  |        특징         | 설명                                                         | 주요 기법                                                    |
  | :-----------------: | :----------------------------------------------------------- | :----------------------------------------------------------- |
  |  원자성(Atomicity)  | 분해가 불가능한 작업의 최소단위<br />연산 전체가 성공 또는 실패(All or Nothing) | Commit/Rollback<br />회복성 보장                             |
  | 일관성(Consistency) | 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야 함 | 무결성 제약 조건<br />병행 제어                              |
  |  격리성(Isolation)  | 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가 | Read Uncommit<br />Read Commit<br />Repeatable Read<br />Serializable |
  | 영속성(Durability)  | 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장 | 회복 기법                                                    |

  

- 트랜잭션 연산

  - 트랜잭션 연산(원자성 주요 기법) <span style="color:blue">*V*</span>

    |      연산      | 설명                                                         |
    | :------------: | :----------------------------------------------------------- |
    |  커밋(Commit)  | 하나의 트랜잭션이 성공적으로 끝나고, 데이터베이스가 일관성 있는 상태에서 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산 |
    | 롤백(Rollback) | 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나, 부분적으로 연산을 취소하는 연산 |

  - 병행 제어(일관성 주요 기법)

    **병행 제어(Concurrency Control)** 는 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다.

    - 목적 <span style="color:blue">*VVV*</span>

      - 데이터베이스의 공유 최대화.
      - 시스템의 활용도 최대화.
      - 데이터베이스의 일관성 유지.
      - 사용자에 대한 응답시간 최소화.

    - 미보장 시 문제점

      |            문제점            | 설명                                                         |
      | :--------------------------: | :----------------------------------------------------------- |
      |    갱신 손실(Lost Update)    | 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류 |
      |  현황 파악오류(Dirty Read)   | 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류 |
      |    모순성(Inconsistency)     | 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류 |
      | 연쇄복귀(Cascading Rollback) | 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우<br />트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류 |

    - 종류 <span style="color:blue">*VV*</span>

      |                             기법                             | 설명                                                         |
      | :----------------------------------------------------------: | :----------------------------------------------------------- |
      |     로킹(Locking) <span style="color:blue">*VVV*</span>      | 같은 자원을 액세스 하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법<br />특징<br />    데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음<br />    로킹 단위가 작아지면 데이터베이스 공유도 증가, 로킹 오버헤드 증가<br />    한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함 |
      |                         낙관적 검증                          | 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법 |
      |         타임 스탬프 순서<br />(Time Stamp Ordering)          | 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법 |
      | 다중버전 동시성 제어<br />(MVCC; Multi Version Concurrency Control) | 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법 |

  - 데이터베이스 고립화 수준(격리성 주요 기법)

    **고립화 수준(Isolation Level)** 은 다음 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도이다.

    - 종류

      |       수준        | 설명                                                         |
      | :---------------: | :----------------------------------------------------------- |
      | Read Uncommitted  | 한 트랜잭션에서 연산 중인 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준<br />연산 중인 데이터에 대한 연산은 불허 |
      |  Read Committed   | 한 트랜잭션에서 연산을 수행할 때, 연산이 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한하는 수준<br />연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용 |
      |  Repeatable Read  | 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신/삭제를 제한하는 수준 |
      | Serializable Read | 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근을 제한하는 수준 |

  - 회복 기법(영속성 주요 기법)

    **회복 기법(Recovery)** 은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업이다.

    - 종류 <span style="color:blue">*VV*</span>

      |                      기법                       | 설명                                                         |
      | :---------------------------------------------: | :----------------------------------------------------------- |
      |               로그 기반 회복 기법               | 자연 갱신 회복 기법(Deferred Update): 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법<br />즉각 갱신 회복 기법(Immediate Update): 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하지 않는 기법 |
      |   체크 포인트 회복 기법(Checkpoint Recovery)    | 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법 |
      | 그림자 페이징 회복 기법(Shadow Paging Recovery) | 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법 |

  

- 트랜잭션 상태 변화

  |               상태                | 설명                                                         |
  | :-------------------------------: | :----------------------------------------------------------- |
  |         활동 상태(Active)         | 초기 상태, 트랜잭션이 실행 중일 때 가지는 상태               |
  | 부분완료 상태(Partially Commited) | 마지막 명령문이 실행된 후에 가지는 상태                      |
  |       완료 상태(Committed)        | 트랜잭션이 성공적으로 완료된 후 가지는 상태                  |
  |         실패 상태(Failed)         | 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태        |
  |        철회 상태(Aborted)         | 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태 |

  

- 트랜잭션 제어(TCL) <span style="color:blue">*VV*</span>

  **트랜잭션 제어(Transaction Control Language)** 는 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어이다.

  |         명령어         | 핵심           | 설명                                |
  | :--------------------: | :------------- | :---------------------------------- |
  |      커밋(COMMIT)      | 트랜잭션 확정  | 트랜잭션을 메모리에 영구적으로 저장 |
  |     롤백(ROLLBACK)     | 트랜잭션 취소  | 트랜잭션 내역을 저장 무효화시킴     |
  | 체크포인트(CHECKPOINT) | 저장 시기 설정 | ROLLBACK을 위한 시점을 지정         |





#### 4. 테이블

**테이블(Table)** 은 데이터를 저장하는 항목인 필드들로 구성된 데이터의 집합체이다.

- 하나의 DB 내에 여러 개의 테이블들로 구성될 수 있다.
- 릴레이션(Relation) 혹은 엔터티(Entity)라고도 불린다.



- 테이블의 구성 조건
  1. 테이블에 포함된 행들은 유일해야하고 중복된 행이 존재하지 않아야 한다.
  2. 테이블에 포함된 행들 간에는 순서가 존재하지 않는다.
  3. 테이블을 구성하는 열들 간에는 순서가 존재하지 않는다.



- 구조

  컬럼 < 테이블 < 데이터베이스



- 용어 <span style="color:blue">*VVV*</span>

  |                용어                | 설명                                                         |
  | :--------------------------------: | :----------------------------------------------------------- |
  |       튜플(Tuple) / 행(Row)        | 테이블 내의 행을 의미하며 레코드(Record)라고도 함<br />튜플은 릴레이션(Relation)에서 같은 값을 가질 수 없음 |
  | 애트리뷰트(Attribute) / 열(Column) | 테이블 내의 열을 의미                                        |
  |         식별자(identifier)         | 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각의 구분을 할 수 있는 논리적인 개념 |
  |      카디널리티(Cardinality)       | 튜플의 개수<br />튜플의 최대 개수 = 각 속성의 모든 도메인값의 곱 |
  |            차수(Degree)            | 애트리뷰트의 개수                                            |
  |           도메인(Domain)           | 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합 |





#### 5. 데이터 사전

**데이터 사전(Data Dictionary)** 은 데이터베이스에 저장되는 테이블, 뷰, 인덱스, 접근 권한 등에 대한 정보를 저장하는 데이터베이스이다.

- 데이터 사전의 내용을 변경하는 권한은 시스템이 가진다. 사용자에게는 읽기 전용 테이블 형태로 제공된다.
- 데이터 사전은 데이터에 대한 데이터를 의미하는 메타데이터(Metadata)로 구성된다.



- 데이터 사전 내용(DBMS 공통)

  - 사용자 정보(아이디, 패스워드, 성별 등)
  - 데이터베이스 객체 정보(테이블, 뷰, 인덱스 등)
  - 무결성 제약 정보(Constraints)
  - 함수, 프로시저 및 트리거

  

- 데이터 사전 검색

  - Oracle 데이터 사전 검색

    - Oracle 사용자는 뷰로 데이터 사전에 접근할 수 있다.

    - Oracle에서 데이터 사전과 관련된 뷰는 DBA\_, ALL\_, USER\_이 있다. 

    - 우선순위:  DBA\_ \> ALL\_ \> USER\_

      | 명령어 | 설명                                                         |
      | :----: | :----------------------------------------------------------- |
      | DBA\_  | 데이터베이스의 모든 객체 조회 가능                           |
      | ALL\_  | 자신의 계정으로 접근 가능한 객체와 타계정의 접근 권한을 가진 모든 객체 조회 가능 |
      | USER\_ | 현재 자신의 계정이 소유한 객체 조회가능                      |

  - MySQL 데이터 사전 검색

    - 데이터 사전은 테이블 형태로 구성되어 있다.
    - MySQL에서 데이터 사전은 information\_schema라는 데이터베이스 안에 존재한다.







### (2) 고급 SQL 작성

#### 1. 뷰

**뷰(View)** 는 논리 테이블로서 사용자에게 사용 관점에서 테이블과 동일하다.

- 뷰는 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있다.
- 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있다.



- 특징 <span style="color:blue">*VVVVV*</span>

  |                       특징                        | 설명                                                         |
  | :-----------------------------------------------: | :----------------------------------------------------------- |
  |             논리적 데이터 독립성 제공             | 데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 데이터에 접근 가능 |
  |              데이터 조작 연산 간소화              | 애플리케이션이 원하는 형태의 논리적 구조를 형성하여 데이터 조작 연산을 간소화 |
  |             보안 기능(접근 제어) 제공             | 특정 필드만을 선택해 뷰를 생성할 경우, 애플리케이션은 선택되지 않은 필드의 조회 및 접근 불가 |
  | 뷰 변경 불가 <span style="color:blue">*VV*</span> | 뷰 정의는 ALTER문을 이용하여 변경할 수 없음<br />뷰는 CREATE 문을 사용하여 정의, DROP문을 사용하여 제거 |



- 목적

  - 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있게 때문이다.

    ```SQL
    예시. SELECT * FROM 뷰이름;
    ```

  - FROM 절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 의의가 있다.

  - 테이블의 중요 데이터 일부만을 제공할 수 있는 장단점이 있다. <span style="color:blue">*V*</span>

    - 장점

      |          장점           | 설명                                                         |
      | :---------------------: | :----------------------------------------------------------- |
      |   논리적 독립성 제공    | 뷰는 논리 테이블이므로 테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨 |
      | 사용자 데이터 관리 용이 | 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능 |
      |   데이터 보안의 용이    | 중요 보안 데이터를 저장 중인 테이블에는 접근 불허<br />보안 데이터에 대한 접근 제어 가능 |

    - 단점

      |         특징          | 설명                                                         |
      | :-------------------: | :----------------------------------------------------------- |
      |  뷰 자체 인덱스 불가  | 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함 |
      |   뷰 정의 변경 불가   | 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성                  |
      | 데이터 변경 제약 존재 | 뷰의 내용에 대한 삽입, 삭제, 변경 제약이 있음                |



- 뷰 명령어

  - 뷰 생성

    ```SQL
    CREATE VIEW 뷰 이름 컬럼 목록 AS 데이터 조회 쿼리;
    ```

    |              상황              | 뷰 생성 쿼리문                                               |
    | :----------------------------: | :----------------------------------------------------------- |
    |        테이블 A 그대로         | CREATE VIEW VW_A AS<br />SELECT *<br />   FROM A;            |
    |       테이블 A 일부 컬럼       | CREATE VIEW VW_B AS<br />SELECT 컬럼1, 컬럼2<br />   FROM A; |
    | 테이블  A와 테이블 B 조인 결과 | CREATE VIEW VW_C AS<br />SELECT *<br />    FROM A, B<br />  WHERE A.컬럼1 = B.컬럼1; |

    - SELECT 문에는 UNION이나 ORDER BY 절을 사용할 수 없다.
    - 컬럼명을 기술하지 않으면 SELECT 문의 컬럼명이 자동으로 사용된다.

  - 뷰 삭제/ 변경 <span style="color:blue">*V*</span>

    - 뷰 정의 자체를 변경하는 것은 불가능하다.
    - 뷰 삭제와 재생성을 통해 뷰에 대한 정의 변경이 가능하다.

    ```SQL
    DROP VIEW 뷰 이름;
    ```

    - 뷰를 통해 접근 가능한 데이터에 대한 변경이 가능하다.





#### 2. 인덱스

**인덱스(Index)** 는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여 주는 자료 구조이다.

- 인덱스는 테이블의 특정 레코드 위치를 알려주는 용도로 사용한다.
- 인덱스는 자동으로 생성되지 않는다.
- 기본 키(PK; Primary Key) 컬럼은 자동으로 인덱스가 생성된다.

```sql
SELECT * FROM 사원 WHERE 이름 = '홍길동';
```

- 테이블 전체 스캔(Table Full Scan): '테이블 이름' 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색한다.
- 인덱스 범위 스캔(Index Range Scan): 인덱스가 생성되어 있을 때, 데이터를 빠르게 찾을 수 있다.
- 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있다.



- 종류

  |                유형                | 설명                                                         |
  | :--------------------------------: | :----------------------------------------------------------- |
  |     순서 인덱스(Ordered Index)     | 데이터가 정렬된 순서로 생성되는 인덱스<br />B-Tree 알고리즘 활용(오름차순/ 내림차순) |
  |      해시 인덱스(Hash Index)       | 해시 함수에 의해 직접 데이터에 키 값으로 접근하는 인덱스<br />데이터 접근 비용이 균일, 튜플(Row) 양에 무관 |
  |    비트맵 인덱스(Bitmap Index)     | 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스<br />수정 변경이 적을 경우 유용 |
  | 함수기반 인덱스(Functional Index)  | 수식이나 함수를 적용하여 만든 인덱스                         |
  |     단일 인덱스(Singled Index)     | 하나의 컬럼으로만 구성한 인덱스<br />주 사용 컬럼이 하나일 경우 사용 |
  |  결합 인덱스(Concatenated Index)   | 두 개 이상의 컬럼으로 구성한 인덱스<br />WHERE 조건으로 사용하는 빈도가 높은 경우 사용 |
  | 클러스터드 인덱스(Clustered Index) | 기본 키(PK) 기준으로 레코드를 묶어서 저장하는 인덱스<br />저장 데이터의 물리적 순서에 따라 인덱스가 생성<br />특정 범위 검색 시 유리함 |



- 인덱스 조작

  1. 인덱스 생성

     - DBMS는 인덱스를 사용하여 빠른 검색을 수행한다.
     - DB 사용자는 DBMS가 인덱스를 사용할 수 있게 준비해주어야 한다.

     ```sql
     CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명);
     ```

     | 파라미터 | 설명                                                  |
     | :------: | :---------------------------------------------------- |
     | [UNIQUE] | 인덱스 걸린 컬럼에 중복 값을 허용하지 않음(생략 가능) |
     | 인덱스명 | 생성하고자 하는 인덱스 테이블명                       |
     | 테이블명 | 인덱스 대상 테이블명                                  |
     |  컬럼명  | 테이블의 특정 컬럼명(복수 컬럼 지정 가능)             |

  2. 인덱스 삭제

     ```SQL
     DROP INDEX 인덱스명;
     ```

  3. 인덱스 변경

     ```SQL
     ALTER [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명);
     ```

     - 기존 인덱스는 삭제하고 신규 인덱스를 생성하는 방식으로 사용이 권고된다.

  4. 인덱스 스캔

     |                구분                 | 설명                                                         |                            개념도                            |
     | :---------------------------------: | :----------------------------------------------------------- | :----------------------------------------------------------: |
     | 인덱스 범위 스캔(Index Range Scan)  | 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식 | ![img](https://blog.kakaocdn.net/dn/bbgbEg/btqMqCETh0B/bS8XU2ddDvFS7Y8AYKQk31/img.jpg) |
     |  인덱스 전체 스캔(Index Full Scan)  | 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식 | ![img](https://blog.kakaocdn.net/dn/AUtRn/btqMkmXEBmB/mQmha7JdeJ5VpFnUxqGKBK/img.jpg) |
     | 인덱스 단일 스캔(Index Unique Scan) | 수직적 탐색만으로 데이터를 찾는 스캔 방식                    | ![img](https://blog.kakaocdn.net/dn/cON17d/btqMgr6nX6H/dztiCjLUc5kDJ4Ut3JbmJk/img.jpg) |
     |  인덱스 생략 스캔(Index Skip Scan)  | 선두 컬럼이 조건 절에 빠졌어도 인덱스를 활용하는 스캔방식    | ![img](https://blog.kakaocdn.net/dn/qA94l/btqMqc0JQwO/pcUJ6L2uslAinUvDfcdilK/img.jpg) |

     이미지 출처 - [riverandeye 블로그 - '[4] 인덱스 확장기능 사용법'](https://riverandeye.tistory.com/entry/4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%99%95%EC%9E%A5%EA%B8%B0%EB%8A%A5-%EC%82%AC%EC%9A%A9%EB%B2%95)





#### 3. 집합 연산자

**집합 연산자(Set Operator)** 는 두 개 이상의 테이블에서 여러개의 질의의 결과를 연결하여 하나로 결합하는 연산자이다.



- 유형

  | 집합 연산자 | 설명                                      |
  | :---------: | :---------------------------------------- |
  |    UNION    | 중복 행이 제거된 쿼리 결과 집합           |
  |  UNION ALL  | 중복 행이 제거되지 않은 쿼리 결과 집합    |
  |  INTERSECT  | 두 쿼리 결과에 공통적으로 존재하는 집합   |
  |    MINUS    | 첫 쿼리에 있고 두 번째 쿼리에는 없는 집합 |

  - UNION

    - 합집합: 두 개의 데이터 집합의 결과에 대해 중복을 제거하고 모두 포함한 결과 반환.

    - 예시

      ```SQL
      SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE SAL <= 2000
       UNION
      SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE SAL >= 1000;
      ```

  - UNION ALL

    - 중복된 항목까지 포함하여 결과를 반환.

  - INTERSECT

    - 교집합.

  - MINUS

    - 차집합: 데이터 집합을 기준으로 다른 데이터 집합과 공통 항목을 제외한 결과만 추출.





#### 4. 조인

**조인(Join)** 은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법.

- 두 릴레이션으로부터 관련된 튜플들을 결합하여 하나의 튜플로 만드는 가장 대표적인 데이터 연결 방법.
- 관계형 데이터베이스의 가장 큰 장점이자 핵심 기능.



- 유형

  |    분류     | 설명                                                         | 유형                                      |
  | :---------: | :----------------------------------------------------------- | :---------------------------------------- |
  | 논리적 조인 | 사용자 SQL 문에 표현되는 테이블 결합 방식                    | 내부 조인, 외부 조인                      |
  | 물리적 조인 | 데이터베이스에 옵티마이저에 의해 내부적으로 발생하는 테이블 결합 방식 | 중첩 반복 조인, 정렬 합병 조인, 해시 조인 |



- 논리적 조인

  - 유형

    |         유형          | 설명                                                         |
    | :-------------------: | :----------------------------------------------------------- |
    | 내부 조인(Inner Join) | 공통 존재 컬럼의 값이 같은 경우를 추출<br />조인의 대상이 되는 컬럼을 명시적으로 선언하기 위해, USING 조건절이나 ON 조건절이 사용됨 |
    | 외부 조인(Outer Join) | 왼쪽 외부 조인(Left Outer Join): 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출<br />오른쪽 외부 조인(Right Outer Join): 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출<br />완전 외부 조인(Full Outer Join): 양쪽의 모든 데이터를 추출 |
    | 교차 조인(Cross Join) | 조인 조건이 없는 모든 데이터 조합을 추출                     |
    | 셀프 조인(Self Join)  | 자기 자신에게 별칭을 지정한 후 다시 조인                     |

    

- 논리적 조인 문법 활용 예시

  - 내부 조인

    '도서' 테이블은 A라는 별칭으로, '도서가격' 테이블은 B라는 명칭으로 설정 후 책번호가 같은 것끼리 조인

    ```sql
    SELECT A.책번호, A.책명, B.가격 /* 같은 이름의 컬럼이 여러 테이블에 있을 경우 '별칭.컬럼명' 형태로 명시. */
      FROM 도서 A [INNER] JOIN 도서가격 B /* INNER라는 키워드는 생략해도 내부 조인이 됨 */
        ON A.책번호 = B.책번호;
    /* [WHERE 검색조건]; 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력되도록 설정 */
    ```

  - 왼쪽 외부 조인

    왼쪽에 위치한 '도서' 테이블 기준으로 왼쪽 외부 조인

    ```SQL
    SELECT A.책번호, A.책명, B.가격
      FROM 도서 A LEFT JOIN 도서가격 B
        ON A.책번호 = B.책번호;
    ```

  - 오른쪽 외부 조인

    왼쪽에 위치한 '도서' 테이블 기준으로 왼쪽 외부 조인

    ```SQL
    SELECT A.책번호, A.책명, B.가격
      FROM 도서 A RIGHT JOIN 도서가격 B
        ON A.책번호 = B.책번호;
    ```

  - 완전 외부 조인

    ```SQL
    SELECT A.책번호, A.책명, B.가격
      FROM 도서 A FULL JOIN 도서가격 B
        ON A.책번호 = B.책번호;
    ```

  - 교차 조인

    조건 설정없이 교차 조인

    ```SQL
    SELECT A.책번호, A.책명, B.책번호, B.가격
      FROM 도서 A CROSS JOIN 도서가격 B;
    /* 조인 조건이 없는 모든 데이터 조합을 추출하기 때문에 ON 절이 없음 */
    ```

  - 셀프 조인

    테이블 내의 다른 컬럼을 조건으로 두어 셀프 조인 수행

    ```SQL
    SELECT A.책번호, A.책명, B.책번호, B.책명 /* '도서' 테이블을 A, B라는 별칭으로 따로 설정 */
      FROM 도서 A JOIN 도서 B
        ON A.선수과목_책번호 = B.책번호;
    ```



- 물리적 조인

  - 중첩 반복 조인

    **중첩 반복 조인(Nested-Loop Join)** 은 2개 이상의 테이블에서 하나의 집합을 기준으로 순차적으로 상대방 row를 결합하여 원하는 결과를 조합하는 조인 방식이다.

    - 선행 테이블의 처리 범위를 하나씩 액세스하면서 추출된 값으로 연결할 테이블을 조인한다.
    - 좁은 범위에 유리한 성능을 보여준다.
    - 순차적으로 처리하며, 임의 접근(Random Access) 위주이다.
    - 후행 테이블(Driven)에는 조인을 위한 인덱스 생성이 필요하다.
    - 실행속도 = 선행 테이블 사이즈 \* 후행 테이블 접근 횟수

  - 정렬 합병 조인

    **정렬 합병 조인(Sort-Merge Join)** 은 조인의 대상 범위가 넓을 경우 발생하는 임의 접근을 줄이기 위한 경우나 연결고리에 마땅한 인덱스가 존재하지 않을 경우 해결하기 위한 조인 방식이다.

    - 양쪽 테이블의 정렬한 결과를 차례로 검색하면서 연결고리 형태로 합병한다.
    - 연결을 위해 랜덤 액세스를 하지 않고 스캔을 하면서 수행한다.
    - 중첩 반복 조인처럼 선행집합 개념이 없다.
    - 정렬을 위한 영역에 따라 효율에 큰 차이가 발생한다.
    - 조인 연산자가 \'=\'이 아닌 경우 중첩 반복 조인보다 유리한 경우가 많다.

  - 해시 조인

    **해시 조인(Hash Join)** 은 해싱 함수(Hasing Function)을 활용하여 테이블 간 조인을 수행하는 방식이다.

    - 해싱 함수는 직접적인 연결을 담당하는 것이 아니라 연결될 대상을 특정 지역(Partition)에 모아두는 역할만을 담당한다.
    - 대용량 처리 선결조건인 랜덤 액세스와 정렬에 대한 부담을 해결할 수 있는 대안이다.
    - 비용기반 옵티마이저에서만 가능하며, CPU 성능에 의존적이다.
    - 해시 테이블 생성 후 중첩 반복 조인처럼 순차적인 처리 형태로 수행한다.





#### 5. 서브쿼리

**서브쿼리(Sub\-Query)** 는 SQL 문 안에 포함된 또 다른 SQL 문을 의미한다.

- 알려지지 않은 기준을 위한 검색을 위해 사용한다.

  ![서브쿼리](http://www.gurubee.net/imgs/oracle/sql/subquery.jpg)

  이미지  출처 - [꿈꾸는 개발자, DBA 커뮤니티 구루비- "Oracle SQL 강좌"](http://www.gurubee.net/lecture/1501)

- 메인쿼리와 서브쿼리 관계는 주종 관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인쿼리의 컬럼 정보를 사용할 수 있으나, 역으로는 성립하지 않는다.



- 유형

  동작하는 방식이나 반환되는 데이터의 형태에 따라 분류할 수 있다.

  - 동작 방식 기준

    |               서브쿼리 종류                | 설명                                                         |
    | :----------------------------------------: | :----------------------------------------------------------- |
    | 비연관 서브쿼리(Un\-Correlated Sub\-Query) | 서브쿼리가 메인쿼리의 컬럼을 가지고 있지 않은 형태<br />메인쿼리에 서브쿼리에서 실행된 결과를 제공하는 용도로 사용 |
    |    연관 서브쿼리(Correlated Sub\-Query)    | 서브쿼리가 메인쿼리의 컬럼을 가지고 있는 형태<br />메인쿼리가 먼저 수행되어 얻은 데이터를 서브쿼리의 조건에 맞는지 확인하는 용도로 사용 |

  - 데이터 형태 기준

    |            서브쿼리 종류            | 설명                                                         |
    | :---------------------------------: | :----------------------------------------------------------- |
    |    단일 행(Single Row) 서브쿼리     | 결과가 항상 1건 이하인 서브쿼리<br />단일 행 비교 연산자 사용 \- =, \<, \<=, \>, \>=, \<\> |
    |   다중 행(Multiple Row) 서브쿼리    | 실행 결과가 여러 건인 서브쿼리<br />다중 행 비교 연산자 사용 \- IN, ALL, ANY, EXIST |
    | 다중 컬럼(Multiple Column) 서브쿼리 | 결과가 여러 컬럼으로 반환되는 서브쿼리<br />메인쿼리의 조건절에 여러 컬럼을 동시에 비교할 때, 서브쿼리와 메인쿼리에서 비교하는 컬럼 개수와 위치가 동일해야 함 |

  - 위치 기준 <span style="color:blue">*VV*</span>

    |   서브쿼리 종류    | 설명                                                         |
    | :----------------: | :----------------------------------------------------------- |
    | SELECT 절 서브쿼리 | 서브쿼리가 SELECT 절 안에 들어있는 형태<br />스칼라 서브쿼리(Scalar Sub\-Query)라고도 불림<br />반드시 단일 행을 리턴해야 함<br />SUM, COUNT, MIN, MAX 등 집계 함수가 많이 쓰임 |
    |  FROM 절 서브쿼리  | 서브쿼리가 FROM 절 안에 들어있는 형태<br />인라인 뷰(Inline Views)라고도 불림<br />뷰처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음 |
    | WHERE 절 서브쿼리  | 서브쿼리가 WHERE 절 안에 들어있는 형태<br />중첩 서브쿼리(Nested Sub\-Query)라고도 불림 |
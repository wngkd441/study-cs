# Ch4. 물리 데이터베이스 설계

### (1) 물리 요소 조사 분석

#### 1. 스토리지

**스토리지(Storage)** 는 데이터를 보존하고 가능한 한 간편하게 액세스할 수 있도록 개발된 기술을 사용하여 정보를 보존하는 저장장치를 의미한다.



- 구성

  - DAS(Direct Attached Storage)

    데이터 서버와 외장형 저장장치를 전용 케이블로 직접 접속하는 방법.

    - 장점: 전용라인의 사용으로 주어진 성능이 보장되며 안정성도 뛰어남.
    - 단점: 저장장치에 따른 접속방법이 서로 상이하여 저장장치 공유에 문제가 있음.

  - NAS(Network Attached Storage)

    LAN을 통해 스토리지와 서버를 접속하는 방식.

    - 파일서버를 통한 파일 시스템을 공유.
    - 장점: 데이터 저장 장치와 서버 간의 독립성을 유지.
    - 단점
      - 데이터 접근 요청에 의한 파일 서버의 병목현상 발생 가능.
      - 파일 서버 종료(Shutdown) 시 스토리지 접근이 불가능.

  - SAN(Storage Area Network)

    서버가 광섬유 채널을 통하여 스토리지를 연결하는 기법.

    - 장점: DAS의 접속 한계성을 극복하여, n개의 서버가 m개의 저장장치 접속 가능.
    - 단점
      - 이기종 서버 환경을 지원하지 않음.
      - 공유 가능한 파일 시스템과 데이터형식이 제한.





#### 2. 분산 데이터베이스

**분산 데이터베이스(Distributed Database)** 는 네트워크상에서 여러 컴퓨터에 물리적으로 분산되어 있지만, 하나의 데이터베이스처럼 인식하도록 논리적으로 통합된 데이터베이스이다.



- 장점 <span style="color:blue">*VVV*</span>

  - 분산 제어가 용이.
  - 지역 자치성이 높음(원격 데이터 처리 센터에 대한 의존도 감소).
  - 효용성과 융통성 높음.
  - 데이터베이스 복제 및 분산을 통해 사용자 측면에서는 향상된 성능 제공.
  - 장애로 인한 데이터 유실 복구 효과적.
  - 시스템 확장 용이.

  

- 단점

  - 복잡성 증가(데이터베이스 설계 및 소프트웨어 개발 비용 증가).
  - 성능 저하(오버헤드 발생).
  - 개발 비용 증가(전문 인력 부족으로 개발 비용 과다).



- 분산 데이터베이스의 구성

  |    구성     | 설명                                                         |
  | :---------: | ------------------------------------------------------------ |
  | 전역 스키마 | 데이터베이스가 마치 분산되어 있지 않은 것처럼 분산 데이터베이스에 포함된 모든 데이터를 정의 |
  | 분할 스키마 | 분산을 위해 단편화된 구성에 대한 정의(일대다 관계)           |
  | 할당 스키마 | 단편들의 위치 정보를 정의<br />유형에 따라 중복/비중복인지가 결정됨 |
  | 지역 스키마 | 물리적 이미지를 해당 지역 DBMS가 관리할 수 있도록 저장하기 위해 변환 |



- 분산 데이터베이스의 투명성 <span style="color:blue">*VVV*</span>

  |                 투명성                  | 설명                                                         |
  | :-------------------------------------: | ------------------------------------------------------------ |
  |   위치 투명성(Location Transparency)    | 사용자나 응용 프로그램이 접근할 데이터의 물리적 위치를 알아야 할 필요가 없는 성질 |
  |  복제 투명성(Replication Transparency)  | 사용자나 응용 프로그램이 접근할 데이터가 물리적으로 여러 곳에 복제되어 있는지의 여부를 알 필요가 없는 성질 |
  |  병행 투명성(Concurrency Transparency)  | 여러 사용자나 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 발생하지 않는 성질<br />로킹, 타임 스탬프 순서 기법 이용 |
  | 분할 투명성(Fragmentation Transparency) | 사용자가 하나의 논리적인 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 장소에 저장되어 있음을 알 필요가 없는 성질 |
  |    장애 투명성(Failure Transparency)    | 데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 생기더라도, 데이터의 무결성을 보존할 수 있는 성질<br />2PC(Phase Commit) 활용 |





#### 3. 데이터베이스 이중화 구성

**데이터베이스 이중화(Database Replication)** 는 물리적으로 떨어져있는 여러 개의 데이터베이스에 대하여 로컬 데이터베이스의 변경된 내용을 원격 데이터베이스에 복제하고 관리하는 기술이다.



- 목적
  - 데이터베이스의 무정지 서비스를 가능하게 함.
  - 사용자는 하나의 데이터베이스에 대해서만 작업 수행.
  - 데이터베이스 이중화시스템에 연결되어 있는 다른 데이터베이스에도 작업 내용 동일하게 적용.
  - 여러 개의 데이터베이스 동시에 관리.



- 형태

  |              형태               | 설명                                                         |
  | :-----------------------------: | ------------------------------------------------------------ |
  |  액티브-액티브(Active-Active)   | 여러 노드가 동시에 가동되는 형태<br />두 노드가 동시에 동작하므로 성능이 좋음 |
  | 액티브-스탠바이(Active-Standby) | 하나의 노드만 가동하고, 나머지 노드들은 대기하는 형태        |





#### 4. 데이터베이스 암호화

**데이터베이스 암호화(Database Encryption)** 는 데이터베이스에 저장된 데이터를 읽기 어려운 값으로 변환하여 권한이 없는 제3자가 볼 수 없도록 저장하는 기술이다.



- 유형

  |           유형            | 설명                                                         |
  | :-----------------------: | ------------------------------------------------------------ |
  | 응용 프로그램 자체 암호화 | 암/복호화 모듈이 API 라이브러리 형태로 각 애플리케이션 서버에 설치되고, 응용프로그램에서 해당 암/복호화 모듈을 호출하는 방식 |
  |      DB 서버 암호화       | 암/복호화 모듈이 DB 서버에 설치되고 DB 서버에서 암/복호화 모듈을 호출하는 방식 |
  |     DBMS 자체 암호화      | DB 서버의 DBMS 커널이 자체적으로 암/복호화 기능을 수행하는 방식 |
  |   DBMS 암호화 기능 호출   | 응용 프로그램에서 DB 서버의 DBMS 커널이 제공하는 암/복호화 API를 호출하는 방식 |
  |      운영체제 암호화      | OS에서 발생하는 물리적인 입출력을 이용한 암/복호화 방식으로 DBMS의 데이터 파일을 암호화하는 방식 |



- 적용 방식

  | 암호화 적용 방식 | 설명                                                         |
  | :--------------: | ------------------------------------------------------------ |
  |   컬럼 암호화    | 테이블에서 특정 컬럼을 암호화하여 데이터를 보관하는 방식<br />API: 암/복호화 모듈을 애플리케이션 서버 내에 설치하고 이 곳에서 암/복호화를 수행하는 구조<br />플러그인(Plug-In): 암/복호화 모듈을 DB 서버 내에 설치하고 이곳에서 암/복호화를 수행하는 구조<br />하이브리드(Hybrid): 플러그인 방식의 단점인 배치 업무의 성능 저하를 보완하기 위해 API 방식을 이용하는 구조 |
  |   블록 암호화    | 애플리케이션상 수정이 필요 없이 DB, OS 자체적으로 블록 단위로 암호화를 제공하는 방식<br />TDE 방식<br />    DBMS에 추가 기능으로 제공되는 암호화 기능을 이용하여 DB 내부에서 데이터 파일 저장 시 암호화<br />    파일에 저장된 내용을 메모리 영역으로 가져올 때, DBMS에 의해 자동으로 복호화되는 방식<br />파일 암호화 방식: 파일 암호화 방식은 OS 상에서 확인이 가능한 개체인 파일을 암호화하는 방식 |





#### 5. 접근제어

**접근제어(Access Control)** 는 불법적인 데이터의 접근으로부터 데이터베이스를 보호하는 기법이다.



- 구성요소

  |      구성요소      | 설명                                                         |
  | :----------------: | ------------------------------------------------------------ |
  |   접근제어 정책    | 자원에 접근하는 사용자의 접근 모드 및 모든 접근 제한 조건 정의 |
  | 접근제어 메커니즘  | 시도된 접근 요청을 정의된 규칙에 대응시켜 검사함으로써 불법적 접근 방어 |
  | 접근제어 보안 모델 | 시스템의 보안 요구를 나타내는 요구 명세로부터 출발하여 정확하고 간결한 기능적 모델 표현 |



- 접근제어 정책 <span style="color:blue">*VV*</span>

  - 신원기반(Identity-based) 접근제어 정책

    - 주체나 기또는 그들이 속해있는 그룹들의 신분에 근거하여 객체에 대한 접근을 제한하는 방법.

    - DAC(Discretionary Access Control)이라고도 불린다.

    |             정책             | 설명                                                         |
    | :--------------------------: | ------------------------------------------------------------ |
    | IBP(Individual-Based Policy) | 단일 사용자가 하나의 객체에 대해 허가를 부여받아 사용하는 정책 |
    |   GBP(Group-Based Policy)    | 복수 사용자가 하나의 객체에 대하여 같은 허가를 함께 부여받아 사용하는 정책 |

  - 규칙기반(Rule-based) 접근제어 정책

    - 객체에 포함된 정보의 비밀성과 이러한 비밀성의 접근정보에 대하여 주체가 갖는 권한에 근거하여 객체에 대한 접근을 제한하는 방법.
    - MAC(Mandatory Access Control)이라고도 불린다.

    |             정책              | 설명                                               |
    | :---------------------------: | -------------------------------------------------- |
    |    MLP(Multi-Level Policy)    | 사용자 및 객체가 각각 부여된 기밀 분류에 따른 정책 |
    | CBP(COmpartment-Based Policy) | 조직 내 특정 집단별로 구분된 기밀 허가에 따른 정책 |

  - 역할기반(Role-based) 접근제어 정책

    - 중앙관리자가 주체와 객체의 상호관계를 제어하며 조직 내에서 맡은 역할에 기초하여 자원에 대한 접근 허용 여부를 결정.
    - RBAC(Role Based Access Control)이라고도 불린다.



- 접근제어 메커니즘

  |         메커니즘         | 설명                                                         |
  | :----------------------: | ------------------------------------------------------------ |
  | ACL(Access Control List) | 주체가 디렉토리나 파일과 같은 특정 시스템 개체에 접근할 수 있는 허가 받은 접근 종류들이 기록된 목록 |
  |   CL(Capability List)    | 주체에게 허가된 자원 및 권한의 목록                          |



- 접근제어 보안모델

  |      모델      | 설명                                                         |
  | :------------: | ------------------------------------------------------------ |
  | 접근 제어 행렬 | 임의적 접근 제어를 관리하기 위한 보안 모델<br />행을 주체, 열은 객체를 표시<br />행과 열은 주체 및 객체의 권한 유형을 표시 |
  |  기밀성 모델   | 기밀성(Confidentiality)에 중점을 둔 수학적인 모델<br />일반적인 상용 환경에서는 기밀성보다는 무결성의 중요성이 높아 부적합<br />모델은 주체와 객체의 보안등급을 근거로 제약 조건을 준수<br />등급 기준: 극비> 비밀> 일반> 미분류<br />대표적인 모델: 벨라파듈라 모델 |
  |  무결성 모델   | 정보 비밀성을 위해 정보의 일방향 흐름 제어를 활용하는 경우 발생<br />기밀성 모델과 같이 주체 및 객체의 보안등급을 기반으로 하며, 제약 조건 역시 유사하게 적용<br />대표적인 모델: 비바 모델, 클락윌슨 모델 |







### (2) DB 물리 속성 설계

#### 1. 파티셔닝

**파티셔닝(Partitioning)** 은 대용량의 테이블을 파티션이라는 보다 작은 논리적인 단위로 나눔으로써 성능 저하 방지 및 관리를 상대적으로 보다 용이하게 하고자 하는 기법이다.



- 특징
  - 물리적 파티셔닝으로 인해 전체 데이터 훼손 가능성이 줄어들고 데이터 가용성이 향상됨.
  - 데이터베이스를 작은 단위로 관리하여 편리.
  - 부하를 각각 파티션들로 분산시켜 성능 향상.



- 유형

  |                   유형                    | 설명                                                         |
  | :---------------------------------------: | ------------------------------------------------------------ |
  |    레인지 파티셔닝(Range Partitioning)    | 분할 키 값이 범위 내에 있는지 여부로 구분하는 파티셔닝 기법  |
  |     해시 파티셔닝(Hash Partitioning)      | 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정하는 파티셔닝 기법 |
  |    리스트 파티셔닝(List Partitioning)     | 값 목록에 파티션을 할당하고 분할 키 값을 그 목록에 비추어 파티션을 선택하는 기법 |
  | 컴포지트 파티셔닝(Composite Partitioning) | 위의 파티셔닝 중 2개 이상의 파티셔닝을 결합하는 파티션 기법  |





#### 2. 클러스터링

**클러스터링(Clustering)** 은 지정된 컬럼 값의 순서대로 데이터 행을 저장하는 방법이다.

- 하나 이상의 테이블을 같은 클러스터 내에 저장이 가능하다.
- 액세스 효율 향상을 위한 물리적 저장 방법으로, 검색 효율은 높여주나 입력, 수정, 삭제 시 부하가 증가할 수 있다.
- 분포도가 넓을수록 유리하고, 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.



- 유형

  |      유형       | 설명                                                         |
  | :-------------: | ------------------------------------------------------------ |
  | 단일 클러스터링 | 클러스터에 하나의 테이블만 생성<br />같은 클러스터 컬럼 값을 가진 row는 같은 장소에 저장되므로 넓은 범위의 데이터를 동시에 엑세스할 때 효과적. |
  | 다중 클러스터링 | 단일 클러스터에 두 개 이상의 테이블을 함께 저장<br />같은 클러스터에 키 컬럼을 가진 각 테이블의 row는 정해진 장소에 같이 저장되므로 테이블 조인 속도를 향상<br />클러스터 컬럼이 수정되면 데이터 값이 수정되므로 추가적인 클러스터체인 블록이 발생하여 효율 감소 |



- 클러스터 설계 시 고려사항

  다음과 같은 특성을 가진 경우 클러스터링 기법으로 저장하는 것을 고려하여 검색의 효율성을 증가시킨다.

  1. 대량의 범위를 자주 액세스하는 경우.
  2. 인덱스를 사용한 처리 부담이 되는 넓은 분포도인 경우.
  3. 여러 개의 테이블이 자주 조인을 일으키는 경우.
  4. 반복 컬럼이 정규화에 의해 어쩔 수 없이 분할된 경우.
  5. UNION, DISTINCT, ORDER BY, GROUP BY가 빈번한 컬럼인 경우.
  6. 수정이 자주 발생하지 않는 컬럼인 경우.





#### 3. 데이터베이스 백업

**데이터베이스 백업(Database Backup)** 은 데이터가 손상되거나 손실될 경우 피해를 최소화하기 위해 현재의 데이터를 저장하는 기법이다.



- 종류

  |                    종류                    | 설명                                                         |
  | :----------------------------------------: | ------------------------------------------------------------ |
  |           전체 백업(Full Backup)           | 백업받고자 하는 데이터 전체에 대해 백업하는 방식<br />데이터베이스 개체, 시스템 테이블, 데이터를 모두 백업 |
  |       차등 백업(Differential Backup)       | 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식<br />차등 백업은 혼자서 존재할 수 없으며, 반드시 전체 백업을 받은 이후에 수행 |
  |       증분 백업(Incremental Backup)        | 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업하는 방식 |
  | 트랜잭션 로그 백업(Transaction Log Backup) | 실제 데이터 파일의 내용을 백업하는 것이 아니라 로그 파일에 기록된 로그를 백업하는 방식<br />트랜잭션 로그 백업을 하려면 전체 백업을 1회 이상 수행해야 함<br />복원되는 속도 느림 |





#### 4. 테이블 저장 사이징

- 필요성
  - 정확한 데이터 용량을 예측하여 저장 공간을 효과적으로 사용하고 확장성을 보장하여 가용성을 높이기 위해 사용.
  - 하드웨 어특성을 고려한 용량설계를 통해 디스크 채널 병목 현상을 최소화.
  - 용량설계를 통해 테이블 및 인덱스 별로 적합한 저장 옵션 지정.



- 테이블 저장 사이징 계산 방법

  `레코드 평균 길이 계산 → 블록에 들어가는 레코드 수 계산 → 테이블 용량 계산`

  1. 레코드 평균 길이 계산

     `(레코드 평균 길이) = (레코드 헤더 사이즈) + (열 헤더 사이즈) + (열 데이터 사이즈)`

     - 레코드 헤더 사이즈 = 3바이트

     - 열 헤더 사이즈

       열의 데이터 길이가 250바이트 이하 = 1바이트

       열의 데이터 길이가 250바이트 초과 = 3바이트

     - 열 데이터 사이즈

       데이터 형에 따라 계산 방법이 다르다.

       | 데이터 형 | 설명                                                         |
       | :-------: | ------------------------------------------------------------ |
       |   CHAR    | 고정인 경우 해당 바이트 수만큼 계산하여 사이징               |
       |  VARCHAR  | `길이 = (1+n/2) 올림` (n=크기)                               |
       |  NUMBER   | NUMBER(자릿수, 소수자리수)<br />`길이 = n/2 올림` (n=자릿수) |

  2. 블록에 들어가는 레코드 수 계산

     `(블록의 빈 공간) = BLOCK_SIZE - (블록 헤더 사이즈) - (예비영역 사이즈)`

     `(블록 헤더 사이즈) = 90 + INITRANS`

     `(예비영역 사이즈) = BLOCK_SIZE - (블록 헤더 사이즈) × PCT_FREE`

     `(블록에 들어가는 레코드 수) = (예비영역 사이즈) / (레코드의 평균 길이)`

     - BLOCK_SIZE = 기본적으로 8KB인 8,192바이트
     - INITRANS(트랜잭션 예약 공간): 트랜잭션의 동시 접근을 위해 미리 할당된 예약 공간
     - PCT_FREE(예비영역 비율): 테이블의 데이터 크기가 변할 때 여유 공간으로 활용하는 비율. 기본 10%.

  3. 테이블 용량 계산

     `(테이블 용량) = (예상 레코드 수) ÷ (블록에 들어가는 레코드 수) × BLOCK_SIZE`



- 테이블 저장 사이징 옵션의 고려사항
  - 트랜잭션 관리 옵션 \- INITRANS 파라미터 값 조정
  - 예비 영역 옵션 \- PCT_FREE 파라미터 값 조정





#### 5. 데이터 지역화

**데이터 지역화(Data Locality)** 는 데이터베이스의 저장 데이터를 효율적으로 이용할 수 있도록 저장하는 방법이다.

- 필요한 위치에 가까이 데이터를 배치.
- 조건: 프로그램은 모든 코드나 데이터를 균등하게 접근하지 않는다는 특성을 기본으로 함.



- 종류

  |           종류            | 설명                                                         | 활용                                           |
  | :-----------------------: | ------------------------------------------------------------ | ---------------------------------------------- |
  |  시간적(Temporal) 지역화  | 최근에 참조된 기억장소가 가까운 장래에 계속 참조될 가능성이 높은 특성 | for나 while 같은 반복문에서 사용하는 조건 변수 |
  |  공간적(Spatial) 지역화   | 최근에 참조된 기억장소와 가까운 기억정보가 계속 참조될 가능성이 높은 특성 | `A[0]`, `A[1]`과 같은 데이터 배열에 연속 접근  |
  | 순차적(Sequential) 지역화 | 별도의 분기(branch)가 없는 한 데이터가 기억장치에 저장된 순서대로 순차적으로 인출되고 실행될 가능성이 높은 특성 | 1:1, 1:N, N:M 관계 존재                        |



- 데이터 지역화를 활용한 관리 기법

  |                 종류                  | 설명                                                         |
  | :-----------------------------------: | ------------------------------------------------------------ |
  |     기억장치 계층구조(Hierarchy)      | \'CPU → 캐시 메모리 → 메인 메모리\' 순으로 접근시간을 효과적으로 단축 |
  | 캐시 접근시간(Cache Access Time) 단축 | 캐시 적중률(Cache Hit Ratio)의 극대화 기능                   |
  |         작업세트(Working Set)         | 하나의 페이지가 자주 접근하는 페이지들의 집합<br />페이지 폴트(page Fault)를 줄임 |







### (3) 물리 데이터베이스 모델링

#### 1. 데이터베이스 무결성

**데이터베이스 무결성(Database Integrity)** 은 데이터를 인가되지 않은 방법으로 변경할 수 없도록 보호하는 특성이다.

- 데이터의 무결성을 유지하는 것은 데이터베이스 관리 시스템(DBMS)의 중요한 기능.
- 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지.
- 권한이 있는 사용자로부터 데이터베이스 보호. <span style="color:blue">*VV*</span>



- 종류 <span style="color:blue">*VVVVVV*</span>

  |                       종류                       | 설명                                                         | 요소                                                  |
  | :----------------------------------------------: | ------------------------------------------------------------ | ----------------------------------------------------- |
  | 개체 무결성 <span style="color:blue">*VV*</span> | 한 엔터티에서 같은 기본 키(PK)를 가질 수 없거나, 기본 키의 속성이 NULL을 허용할 수 없음 | 기본 키<br />유니크 인덱스(Unique Index)              |
  |                   참조 무결성                    | 외래 키(FK)가 참조하는 다른 개체의 기본 키에 해당하는 기본 키 값이나 NULL이어야 함 | 외래 키                                               |
  |                   속성 무결성                    | 속성의 값은 기본값, NULL 여부, 도메인이 지정된 규칙을 준수해야 함 | 체크(CHECK)<br />NULL / NOT NULL<br />기본값(DEFAULT) |
  |                  사용자 무결성                   | 사용자의 의미적 요구사항을 준수해야 함                       | 트리거(Trigger)<br />사용자 정의 데이터 타입          |
  |                    키 무결성                     | 한 릴레이션에 같은 키 값을 가진 튜플들을 허용할 수 없음      | 유니크(Unique)                                        |





#### 2. 컬럼 속성

**컬럼(Column)** 은 테이블을 구성하는 요소로, 데이터 타입 및 길이 등으로 정의된다.



- 구성요소

  |     구성요소     | 설명                                           |
  | :--------------: | ---------------------------------------------- |
  | 내장 데이터 형식 | 문자, 숫자, 시간, 대형 객체 등을 정의          |
  | 확장 데이터 형식 | 행, 컬렉션, 사용자 정의, 데이터 형식 등을 지원 |



- 컬럼 고려사항

  |           고려사항           | 설명                                                         |
  | :--------------------------: | ------------------------------------------------------------ |
  | 타입에 따른 물리적 순서 조정 | 고정 길이 컬럼이고 NOT NULL인 컬럼은 앞편에 정의<br />가변 길이 컬럼은 뒤편에 정의<br />NULL 값이 많을 것으로 예상되는 컬럼은 뒤편으로 배치 |
  | DBMS별 물리적 순서조정 특성  | 값이 변경될 때 체인 발생을 억제하고 저장 공간의 효율적인 사용을 위해 필요 |
  | 데이터 타입, 길이 지정 고려  | 가변 길이 데이터 타입은 예상되는 최대 길이로 정의<br />고정 길이 데이터 타입은 최소의 길이를 지정<br />소수점 이하 자리수의 정의는 반올림되어 저장되므로 정확성을 확인하고 정의 |
  |       컬럼 간 비교방법       | 비교 연산에서 두 컬럼 사이에 데이터 타입과 같은 길이를 사용  |





#### 3. 키

**키(Key)** 는 데이터베이스에서 조건을 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 기준이 되는 속성이다.



- 특성

  |  특성  | 설명                                                         |
  | :----: | ------------------------------------------------------------ |
  | 유일성 | 식별자에 의해 엔터티 타입 내에 모든 엔터티들이 유일하게 구분 |
  | 최소성 | 최소한의 속성으로 식별자 구성                                |



- 종류 <span style="color:blue">*VV*</span>

  |                             종류                             | 설명                                                         |
  | :----------------------------------------------------------: | ------------------------------------------------------------ |
  |  기본 키(Primary Key) <span style="color:blue">*VVV*</span>  | 테이블의 각 튜플들을 고유하게 식별하는 컬럼                  |
  |                    대체 키(Alternate Key)                    | 후보 키 중에서 기본 키로 선택되지 않은 키                    |
  | 후보 키(Candidate Key) <span style="color:blue">*VVVVVVV*</span> | 테이블에서 각 튜플들을 구별하는데 기준이 되는 컬럼<br />기본 키와 대체 키를 합친 키 |
  |    슈퍼 키(Super Key) <span style="color:blue">*V*</span>    | 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못하는 키 |
  |   외래 키(Foreign Key) <span style="color:blue">*V*</span>   | 테이블 간의 참조 데이터 무결성을 위한 제약 조건<br />한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키 |



- 기본 키와 외래 키의 상호관계

  |   구분    | 기본 키                                         | 외래 키                                                      |
  | :-------: | :---------------------------------------------- | ------------------------------------------------------------ |
  |   개념    | 테이블의 각 튜플들을 고유하게 식별하는 키       | 한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키   |
  |   제약    | 개체 무결성(NOT NULL)<br />본질적 제약(단일 값) | 참조 무결성(값 존재 또는 NULL)<br />내재적 제약(스키마 지정) |
  | 상호 관계 | NOT NULL 기반 생성                              | 기본 키 기반 생성(기본 키 값이거나 NULL 가능, 중복 가능)     |







### (4) DB 반 정규화

#### 1. 반 정규화

**반 정규화(De-Normalization)** 는 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다. <span style="color:blue">*V*</span>

- 비정규화, 역정규화라고도 불린다.



- 특징
  - 장점
    - 반 정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가.
  - 단점
    - 데이터의 일관성 및 정합성 저하
    - 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음.
  - 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화에 우선순위를 둘 것인지 비교하여 조정하는 과정 필요.



- 반 정규화 기법

  |  구분  |    수행 방법     | 설명                                                         |
  | :----: | :--------------: | ------------------------------------------------------------ |
  | 테이블 |   테이블 병합    | 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능을 향상<br />슈퍼타입/서브타입 테이블 통합을 통해 성능 향상 |
  | 테이블 |   테이블 분할    | 수평 분할: 테이블 분할에 레코드를 기준으로 활용<br />수직 분할<br />     하나의 테이블이 가지는 컬럼의 개수가 증가하는 경우 활용<br />     갱신 위주의 속성 분할, 잦 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할 |
  | 테이블 | 중복 테이블 추가 | 대량의 데이터들에 대한 집계함수를 사용하여 실시간 통계정보를 계산하는 경우, 효과적인 수행을 위해 중복 테이블 추가<br />집계 테이블 추가: 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것으로, 트리거의 오버헤드에 유의 필요<br />진행 테이블 추가: 이력 관리 등의 목적으로 추가하는 테이블로, 적절한 데이터양의 유지와 활용도를 높이기 위해 기본키를 적절히 설정<br />특정 부분만을 포함하는 테이블 추가: 데이터가 많은 테이블의 특정 부부만을 사용하는 경우 해당 부분만으로 새로운 테이블 생성 |
  |  컬럼  |   컬럼 중복화    | 조인 성능 향상을 위한 중복 허용                              |
  |  관계  |  중복관계 추가   | 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이때 발생할 수 있는 성능 저하를 예방하기 위해 추가적 관계를 맺는 방법 |







### (5) 물리 데이터 모델 품질 검토

#### 1. 물리 데이터 모델 품질 기준

물리 데이터 모델은 시스템 성능에 대해 직접적인 영향을 미치기 때문에 성능 문제를 사전에 검토하여 최소화하는 노력이 절대적으로 필요하다.



- 물리 데이터 모델 품질 요소

  |  요소  | 설명                                                         |
  | :----: | ------------------------------------------------------------ |
  | 정확성 | 데이터 모델이 표기법에 따라 정확하게 표현되었고, 업무 영역 또는 요구사항이 정확하게 반영되었음을 의미 |
  | 완전성 | 데이터 모델의 구성요소를 정의하는 데 있어서 누락을 최소화하고, 요구사항 및 업무 영역 반영에 있어서 누락이 없음을 의미 |
  | 준거성 | 제반 준수 요건들이 누락 없이 정확하게 준수되었음을 의미      |
  | 최신성 | 데이터 모델이 현행 시스템의 최신 상태를 반영하고 있고, 이슈 사항들이 지체없이 반영되고 있음을 의미 |
  | 일관성 | 여러 영역에서 공통 사용되는 데이터 요소가 전사 수준에서 한 번만 정의되고 이를 여러 다른 영역에서 참조/활용되면서, 모델 표현상의 일관성을 유지하고 있음을 의미 |
  | 활용성 | 작성된 모델과 그 설명 내용이 이해관계자에게 의미를 충분하게 전달할 수 있으면서, 업무 변화 시에 설계 변경이 최소화되도록 유연하게 설계되어 있음을 의미 |





#### 2. 물리 E-R 다이어그램

- 논리 데이터 모델의 물리 데이터 모델로 변환

  |           논리적 설계           |     물리적 설계      | 데이터베이스 |
  | :-----------------------------: | :------------------: | ------------ |
  |         엔터티(Entity)          |    테이블(Table)     | 테이블       |
  |         속성(Attribute)         |     컬럼(Column)     | 컬럼         |
  |  주 식별자(Primary Identifier)  | 기본 키(Primary Key) | 기본 키      |
  | 외래 식별자(Foreign Identifier) | 외래 키(Foreign Key) | 외래 키      |
  |       관계(Relationship)        |  관계(Relationship)  | \-           |



- 관계 변환

  1. 1:1 변환

     - 논리 데이터 모델에서 1:1 관계는 일반적이지 않은 형태.
     - 상재거으로 자주 사용되는 테이블에 외래 키를 포함하는 것이 유리.

  2. 1:N 변환

     - 논리 데이터 모델의 관계에서 가장 보편적 형태의 관계.
     - N 측의 관계 컬럼에 선택사양이 결정됨.

  3. N:M 변환

     - 실제 데이터 환경에서 빈번하게 등장하는 논리 데이터 모델의 배타적 관계.

     - 물리 모델링에서 생성하는 방법이 일반적인 관계 변환 방법과 차이가 있음.

     - N:M 변환 케이스

       |    케이스    | 설명                                                         |
       | :----------: | ------------------------------------------------------------ |
       | 외래 키 분리 | 관계별로 관계 컬럼을 생성하는 방법으로 실제 외래 키의 제약 조건 생성 가능<br />체크 제약 조건의 추가적 생성 필요 |
       | 외래 키 결합 | 관계들을 하나의 관계 컬럼으로 통합 생성하는 방법<br />실제 외래 키 제약 조건의 생성은 불가능하고 다수의 관계를 선별하여 구분하기 위한 별도의 컬럼 필요 |



- 데이터베이스를 이용하는 프로그래밍의 수행 속도 향상을 위해 추가되는 테이블이나 컬럼으로 관리 가능.
- 논리 모델링에서 정의된 논리적인 데이터 타입을 물리적인 DBMS 특성과 성능의 고려르 통해 최적 데이터 타입을 선택해야 함.
- 이름의 변환 과정에서 데이터베이스의 활용 및 관리를 고려하여 전사적으로 사전에 수립된 데이터 표준을 준수.
- 데이터 표준에는 표준 용어, 표준 도메인, 표준 명명 규칙 등이 존재.





#### 3. CRUD 분석 

**CRUD 분석** 은 데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석하는 기법이다. <span style="color:blue">*V*</span>

- 프로세스와 데이터 사이에 관계 의존성을 CREATE, READ, UPDATE, DELETE 연산으로 프로세스와 테이블 간에 매트릭스를 만들어서 트랜잭션을 분석.

- 주로 CRUD 매트릭스를 통해 관계를 표현.

  **CRUD 매트릭스(CRUD Matrix)** 는 프로세스와 데이터 사이에 관계 의존성을 CRUD(CREATE, READ, UPDATE, DELETE)로 표현한 매트릭스이다.

  - 필요성

    |        필요성         | 설명                                                         |
    | :-------------------: | ------------------------------------------------------------ |
    |   모델링 작업 검증    | 분석 단계의 데이터 모델과 프로세스 모델에 대한 작업 검증 역할을 수행 |
    |      중요 산출물      | 시스템 구축 단계에서 애플리케이션 개발 시 필요하며 중요한 산출물 |
    | 테스트 시 사용 산출물 | 애플리케이션을 객관적 자료를 사용하여 테스트 시 중요 테스트 케이스 역할을 수행 |
    | 인터페이스 현황 파악  | 전체 업무의 인터페이스 파악이 가능                           |

  - 구성요소

    |   구성요소    | 설명                                                         | 예시                   |
    | :-----------: | :----------------------------------------------------------- | ---------------------- |
    |  엔터티 타입  | 프로세스에 영향을 받는 데이터<br />데이터베이스의 튜플 역할  | 고객, 제품, 주문, 목록 |
    | 단위 프로세스 | 엔터티에 영향을 주는 업무 단위<br />데이터베이스의 트랜잭션 역할 | 고객 등록, 주문 조회   |
    |     CRUD      | 프로세스가 엔터티에 주는 영향<br />Create, Read, Update, Delete | 생성, 조회, 수정, 삭제 |

  - 규칙

    CRUD 매트릭스 규칙을 통해 매트릭스에 빠진 부분이 있는지 확일할 수 있다.

    |    구분     | 규칙                                                      | 설명                                                         |
    | :---------: | :-------------------------------------------------------- | ------------------------------------------------------------ |
    | 엔터티 타입 | 모든 엔터티에 "C"가 존재                                  | 데이터는 1번 생성되어야 함<br />데이터 생성이 없으면 데이터의 읽기, 갱신, 삭제가 불가능 |
    | 엔터티 타입 | 모든 엔터티에 "R"이 존재                                  | 데이터는 최소한 1번은 읽어야 함                              |
    | 엔터티 타입 | 모든 엔터티에 "CRUD"가 존재                               | 엔터티에 C, R, U, D 중 하나라도 존재해야 함                  |
    |  프로세스   | 두 개 이상의 단위 프로세스가 하나의 엔터티 타입 생성 불가 | 같은 엔터티에 두 개 이상의 "C"가 존재하면 안 됨              |
    |  프로세스   | 모든 단위 프로세스는 하나 이상의 엔터티 타입에 표기       | 단위 프로세스에 C, R, U, D 중 하나라도 존재해야 함           |





#### 4. SQL 성능 튜닝

**SQL 성능 튜닝** 은 최소의 자원을이용하여 데이터베이스로부터 최적의 성능을 제공하도록 하는 개선활동이다.

- 튜닝 결과에 따라 동일한 결과에 대해서 성능 차이가 크게 발생함.



- 기법

  |        기법         | 설명                                              |
  | :-----------------: | ------------------------------------------------- |
  |   옵티마이저 조정   | 옵티마이저의 실행계획을 점검 및 조정              |
  |      힌트 사용      | 힌트를 사용해 원하는 실행계획으로 유도            |
  | 부분 범위 처리 사용 | 일부만 액세스한 후 결과를 리턴해 빠른 응답을 제공 |
  |     인덱스 활용     | 인덱스를 무용지물로 만드는 SQL을 수정             |
# 2. Queue의 종류



## 선형 Queue

### 선형 큐의 특징

- 1차원 리스트를 이용한 큐
  - 큐의 크기 = 리스트의 크기
  - front = 저장된 첫 번째 원소의 인덱스
  - rear = 저장된 마지막 원소의 인덱스
- 상태표현
  - 초기 상태: front = rear = \-1
  - 공백 상태: front = rear
  - 포화 상태: rear = n\-1(n: 리스트의 크기, n-1: 리스트의 마지막 인덱스)



### 선형 큐의 구현

1. 초기 createQueue(): 초기 공백 큐 생성

   - 크기 n인 1차원 리스트 생성
   - front, rear = \-1로 초기화

2. enQueue(item): 큐에 삽입

   - rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련.
   - 그 인덱스에 해당하는 리스트 원소 Q[rear]에 item을 저장.

   ```python
   def enQueue(item):
       global rear
       if isFull(): # rear = len(Q)
           print("Queue_Full")
       else:
           rear += 1
           Q[rear] = item
   ```

3. dequeue(): 원소 삭제

   - front 값을 하나 증가시켜 큐에 남아있는 첫 번째 원소로 이동.
   - 새로운 첫 번째 원소를 리턴함으로써 삭제와 동일한 기능을 함.

   ```python
   def deQueue():
       global front
       if isEmpty():
           print("Queue_Empty")
       else:
           front += 1
           return Q[front]
   ```

4. isEmpty(), isFull(): 공백상태 및 포화상태 검사

   - 공백상태: front = rear

   ```python
   def isEmpty():
       return front == rear
   ```

   - 포화상태: rear = n-1

   ```python
   def isFUll():
       return rear == len(Q) - 1
   ```

5. Qpeek(): 가장 앞에 있는 원소를 반환

   - 현재 front의 한자리 뒤(front+1)에 있는 원소, 즉 큐의 첫 번째에 있는 원소를 반환.



### 선형 큐의 문제점

1. 리스트의 크기를 고정하여 생성하면 사용할 큐의 크기만큼을 미리 확보함. 따라서, 메모리의 낭비 발생.

2. 삽입, 삭제를 계속할 경우, 리스트의 앞부분에 활용할 수 있는 공간이 있음에도, 포화 상태로 인식(rear=n\-1)하여 더 이상의 삽입을 수행할 수 없음.



- 선형 큐의 장점: 삽입, 삭제의 처리속도 빠름
- 선형 큐의 단점: 메모리의 낭비가 심함
  - 해결법
    1. 원형 큐 사용으로 메모리 절약.
    2. 파이썬의 리스트 특성(동적 메모리)을 사용한 큐 사용으로 메모리 절약.
    3. 단순연결 리스트로 구현.
    4. 큐 라이브 사용.





## 원형 Queue

### 원형 Queue

1차원 리스트를 사용하되, 논리적으로 리스트의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용.



### 원형 큐의 특징

- 초기 공백 상태: front = rear = 0

- Index의 순환

  - front와 rear의 위치가 리스트의 마지막 인덱스인 n-1을 가리킨 후, 논리적 순환을 이루어 리스트의 처음 인덱스인 0으로 이동.
  - 이를 위해 나머지 연산자 `%`사용.

- front 변수: 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠.

- 삽입 위치 및 삭제 위치

  | 테이블 인덱스 |       삽입 위치       |        삭제 위치         |
  | :-----------: | :-------------------: | :----------------------: |
  |    선형 큐    |    rear = rear + 1    |    front = front + 1     |
  |    원형 큐    | rear = (rear + 1) % n | front = (front + 1 ) % n |



### 원형 큐의 기본 연산 과정

1. 큐 생성: create Queue
   - front = rear = 0
   - len(cQ) = 4
2. 원소 A 삽입: enQueue(A)
   - rear += 1, cQ[1] = A
3. 원소 B 삽입: enQueue(B)
   - rear += 1, cQ[2] = B
4. 큐 삭제: deQueue()
   - front += 1, cQ[1] = []
5. 원소 C 삽입: enQueue(C)
   - rear += 1, cQ[3] = C
6. 원소 D 삽입: enQueue(D)
   - rear = 0, cQ[0] = D
   - front 자리는 사용하지 않기 때문에 큐는 포화 상태



### 원형 큐의 구현

1. 초기 createQueue(): 공백큐 생성

   - 크기 n인 1차원 리스트 생성.
   - front = rear = 0으로 초기화.

2. isEmpty(), isFull(): 공백상태 및 포화상태 검사

   - 공백상태: front = rear

   ```python
   def isEmpty():
       return front == rear
   ```

   - 포화상태: 삽입할 rear의 다음 위치(`(rear+1) % n = front`) = 현재 front

   ```python
   def isFull():
       return (rear+1)%len(cQ) = front
   ```

3. enQueue(item): 원소 삽입

   - rear 값을 조정하여 새로운 원소를 삽입할 자리를 마련함
   - `rear = (rear+1)%n`
   - 인덱스에 해당하는 리스트원소 cQ[rear]에 item을 저장.

   ```python
   def enQueue(item):
       global rear
       if isFull():
           print("Queue_Full")
       else:
           rear = (rear+1) % len(cQ)
           cQ[rear] = item
   ```

4. deQueue(): 원소 삭제

   - front 값을 조정하여 삭제할 자리를 준비함.
   - 새로운 front 원소를 리턴함으로써 삭제와 동일한 기능을 함.

   ```python
   def deQueue():
       global front
       if isEmpty():
           print("Queue_Empty")
       else:
           front = (front+1) % len(cQ)
           return cQ[front]
   ```





### 파이썬으로 구현한 원형 큐의 삽입 및 삭제 함수

```python
cQ_SIZE = 3
cQ = [0] * cQ_SIZE

# front, rear를 0으로 초기화
front = rear = 0

# FIFO 구조
enQueue('A')
enQueue('B')
enQueue('C')
print(deQueue())
print(deQueue())
print(deQueue())
```





## 리스트의 특성을 사용한 Queue

1. 파이썬의 리스트 특성을 사용한 큐
   - 리스트는 크기를 동적으로 변경할 수 있음.
   - 메모리 절약.
   - 삽입, 삭제 시 복사, 데이터를 이동시키는 연산을 수행하는데 많은 시간 소모.
2. 리스트의 메서드
   - append(item): 마지막 위치에 원소 추가
   - pop(index): index 위치에 원소 삭제
3. front는 리스트의 맨 앞: \-1
4. rear는 리스트이 맨 뒤: len(queue) \-1



### 파이썬의 리스트 특성을 사용한 큐의 삽입 및 삭제 함수

```python
queue = [] # 공백 리스트 생성
# front = -1
# rear = len(queue) - 1

# FIFO 구조
enQueue('A')
enQueue('B')
enQueue('C')
print(deQueue())
print(deQueue())
print(deQueue())
```



## 연결 Queue

### 연결 큐의 특징

- 단순 연결 리스트(Linked List)를 이용한 큐
  - 큐의 원소: 단순 연결 리스트의 노드.
  - 큐의 원소 순서: 노드의 연결 순서, 링크로 연결되어 있음.
  - front: 첫 번째 노드를 가리키는 링크.
  - rear: 마지막 노드를 가리키는 링크.
- 상태 표현
  - 초기 상태: front = rear = None
  - 공백 상태: front = rear = None
  - 계속해서 노드를 추가할 수 있는 연결 리스트의 특성때문에 포화 상태는 없음.



### 연결 큐의 연산 과정

1. 큐 생성: createLinkedQueue()
   - front = rear = None
2. 원소 A 삽입: enQueue(A)
   - front = rear = A의 위치
   - A 노드의 링크 = None
3. 원소 B 삽입: enQueue(B)
   - A 노드의 링크 = rear = B의 위치
   - B 노드의 링크 = None
4. 원소 삭제: deQueue()
   - front = (A가 가리키던) B의 위치
5. 원소 C 삽입: enQueue(C)
   - B 노드의 링크 = rear = C의 위치
   - C 노드의 링크 = None
6. 원소 삭제: deQueue()
   - front = (B가 가리키던) C의 위치
7. 원소 삭제: deQueue()
   - front = rear = None: 공백 상태



### 연결 큐의 구현

1. createLinkedQueue(): 초기 공백 큐 생성

   - 리스트 노드 없이 포인터 변수만 생성.
   - front와 rear를 None으로 초기화

   ```python
   front = None
   rear = None
   ```

2. isEmpty(): 공백상태 검사

   - 공백상태: front = rear = None

   ```python
   def isEmpty():
       return front == None
   ```

3. enQueue(item): 원소 삽입

   - 새로운 노드 생성 후 데이터 필드에 item 저장.
   - 연결 큐가 공백인 경우, front와 rear에 삽입할 때 노드의 위치 지정.
   - 연결 큐가 공백이 아닌 경우, 기존 마지막 원소의 링크에 새로 삽입한 노드의 위치를 지정해주고, rear가 새 노드를 가리키게 함.

   ```python
   def enQueue(item):
       global front, rear
       newNode = Node(item) # 새로운 노드 생성
       if isEmpty():
           front = newNode
       else:
           rear.next = newNode
       rear = newNode
   ```

4. deQueue(): 원소 삭제

   - old가 지울 노드를 가리키게 하고, front 재설정.
   - 삭제 후 공백 큐가 되는 경우, rear도 None으로 설정.
   - old가 가리키는 노드를 삭제하고 메모리 반환.

   ```python
   def deQueue():
       global front, rear
       if isEmpty():
           print("Queue_Empty")
           return Node
       
       item = front.item
       front = front.next
       if isEmpty():
           rear = None
       return item
   ```



### 파이썬으로 구현한 연결 큐

```python
class Node:
    def __init__(self, item, n=None):
        self.item = item
        self.next = n
        
def enQueue(item):
    global front, rear
    newNode = Node(item) # 새로운 노드 생성
    if isEmpty():
        front = newNode
    else:
        rear.next = newNode
    rear = newNode
    
def isEmpty():
    return front == None

def deQueue():
    global front, rear
    if isEmpty():
        print("Queue_Empty")
        return Node
    
    item = front.item
    front = front.next
    if isEmpty():
        rear = None
    return item

def Qpeek():
    return front.item

def printQ():
    f = front
    s = ""
    while f:
        s += f.item + ""
        f = f.next
    return s

front = None
rear = None

enQueue('A')
enQueue('B')
enQueue('C')
printQ()
print(deQueue())
print(deQueue())
print(deQueue())
```





## Queue 라이브러리

### 큐 모듈

- 큐 모듈에 정의된 클래스

  |             클래스             | 내용                                                         |
  | :----------------------------: | ------------------------------------------------------------ |
  |     `queue.Queue(maxsize)`     | 선입선출(FIFO) 큐 객체를 생성                                |
  |   `queue.LifoQueue(maxsize)`   | 스택 개념의 후입선출(LIFO) 큐 객체 생성                      |
  | `queue.PriorityQueue(maxsize)` | 우선순위 큐 객체를 생성, 입력되는 아이템의 형식은 (순위,아이템)의 튜플로 입력되며, 우선순위는 숫자가 작을수록 높은 순위를 가짐 |

- maxsize는 최대 아이템수, 지정하지 않거나 음수이면 내용만큼 늘어남.

- 제시된 3개의 클래스는 다음과 같은 메서드를 동일하게 가짐.

  |             메서드              | 내용                                            |
  | :-----------------------------: | ----------------------------------------------- |
  |            `qsize()`            | 큐 객체에 입력된 아이템 개수를 반환             |
  | `put(item[, block[, timeout]])` | 큐 객체에 아이템을 입력                         |
  |    `get([block[, timeout]])     | 생성된 큐 객체 특성에 맞추어, 아이템 1개를 반환 |
  |            `empty()`            | 큐 객체가 비어있으면 True 리턴                  |
  |            `full()`             | 큐 객체가 꽉차있으면 True 리턴                  |

- 클래스의 정렬 방식에 따라 get 계열의 메서드 결과가 달라짐.



### 큐 모듈 활용

- 선입선출의 큐 개념을 구현한 큐 클래스 활용.

```python
import queue

q = queue.Queue() # FIFO 구조 큐 생성
q.put('A')
q.put('B')
q.put('C')

while not q.empty():
    print(q.get())
```
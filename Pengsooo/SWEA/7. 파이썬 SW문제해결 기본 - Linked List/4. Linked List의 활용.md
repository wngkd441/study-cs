# 4. Linked List의 활용



## List를 이용한 Stack

- 스택의 원소: 리스트의 노드
  - 스택 내의 순서는 리스트의 링크를 통해 연결됨.
  - Push: 리스트의 마지막에 노드 삽입.
  - Pop: 리스트의 마지막 노드 반환/삭제.



- 변수 Top: 리스트의 마지막 노드를 가리키는 변수.
  - 초기상태: Top = None



## List를 이용한 Stack의 연산

### 리스트를 이용해 Push와 Pop 연산 구현

1. None 값을 가지는 노드를 만들어 스택 초기화
2. 원소 A 삽입: `push(A)`
   - Top = 원소 A의 주소
3. 원소 B 삽입: `push(B)`
   - Top = 원소 B의 주소
4. 원소 C 삽입: `push(C)`
   - Top = 원소 C의 주소
5. 원소 반환: `pop()`
   - Top = 원소 B의 주소



### Push/Pop 연산의 알고리즘

```python
def push(i): # 원소 i를 스택 top(맨앞) 위치에 push
    global top
    top = Node(i, top) # 새로운 노드 생성
```

```python
def pop(): # 스택의 top을 pop
    global top
    if top == None: # 빈 리스트이면
        print("error")
    else:
        data = top.data
        top = top.link # top이 가리키는 노드를 바꿈
        return data
```



## 우선순위 Queue

### 우선순위 큐의 구현과 기본 연산

- 우선순위 큐의 구현: 연결 리스트를 이용하여 구현.
- 우선순위 큐의 기본 연산: 삽입(enQueue), 삭제(deQueue)



### 순차 리스트를 이용한 우선순위 큐 구현

- 순차 리스트를 이용하여 자료 저장.
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조.
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨.
- 문제점: 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함. 따라서, 소요되는 시간이나 메모리 낭비가 큼.



### 연결 리스트를 이용한 우선순위 큐 구현

- 연결 리스트를 이용하여 자료 저장.
- 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조.
- 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨.
- 배열 대비 장점
  - 삽입/삭제 연산 이후 원소의 재배치가 필요 없음.
  - 메모리의 효율적인 사용이 가능함.


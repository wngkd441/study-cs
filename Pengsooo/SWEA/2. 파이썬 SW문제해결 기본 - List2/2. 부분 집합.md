# 2. 부분 집합



## 부분 집합의 합

- Ex. 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아보는 문제.
  - 완전 검색기법으로 부분 집합 합 문제를 풀기 위해서, 집합의 모든 부분 집합을 생성한 후, 각 부분 집합의 합을 계산.
  - 주어진 집합의 부분 집합을 생성하는 방법 필요.



## 부분 집합의 개수

어떤 집합의 부분 집합을 구할 경우 부분 집합의 총 개수를 구하는 문제.

- 집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 개수는 2^n개.
- 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 경우를 모든 원소에 적용한 경우의 수와 같음.



## 부분 집합 문제 알고리즘

### Loop를 이용하여 확인하고, 부분 집합을 생성하는 방법

```python
bit = [0, 0, 0, 0] # 비트 리스트: 대상 리스트의 각 원소를 포함할지 말지 정하는 리스트, 0과 1로 이루어짐.
for i in range(2):
    bit[0] = i # 0번째 원소
    for j in range(2):
        bit[1] = j # 1번째 원소
        for k in range(2):
            bit[2] = k # 2번째 원소
            for l in range(2):
                bit[3] = l # 3번째 원소
                print(bit) # 부분집합
```



### 비트 연산자

0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자.

- 종류

  - `&`: 비트 단위로 AND 연산을 함.
  - `|`: 비트 단위로 OR 연산을 함.
  - `<<`: 피연산자의 비트 열을 왼쪽으로 이동시킴.
  - `>>`: 피연산자의 비트 열을 오른쪽으로 이동시킴.

- 활용

  `1<<n`: 원소가 n개일 경우, 모든 부분 집합의 개수(2^n)를 의미.

  `i & (1<<j)`: i에서 j번째 비트가 1인지 아닌지를 리턴.



### 보다 간결하게 부분 집합을 생성하는 방법

```python
arr= [3, 6, 7, 1, 5, 4]
n = len(arr) # n: 리스트 원소의 개수

for i in range(1<<n): # 1<<n: 부분 집합의 개수
    for j in range(n): # 원소의 수만큼 비트를 비교
        if i&(1<<j): # i의 j번째 비트가 1이면
            print(arr[j], end=',') # j번째 원소 출력
    print()
```
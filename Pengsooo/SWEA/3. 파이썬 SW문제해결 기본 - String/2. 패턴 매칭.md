# 2. 패턴 매칭



## 문자열 교체하기

- 문자열 내에서 '1, 2'라는 문자열을 'one, two'라는 문자열로 변경하는 경우
  1. 찾는 문자열 뒤에 있는 문자열을 임시 문자열에 복사.
  2. 문자열을 교체. -> \'Pattern Matching\'
  3. 맨 뒤에, 복사했던 문자열을 붙여넣음.



## 패턴 매칭 알고리즘

**패턴매칭**: 본문에서 특정한 문자열을 찾는 것.

- 고지식한 패턴 검색 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘



## 고지식한 알고리즘

### 고지식한 알고리즘(Brute Force)

본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작.

1. 비교하고자 하는 패턴과 원본 문자열의 첫 인덱스부터 시작.
2. 하나씩 비교.
3. 서로 다른 문자일 때 실패.
4. 검색 대상의 인덱스는 한 칸 뒤로, 검색하고자 하는 패턴의 인덱스는 처음부터.
5. 1~4 반복.

```python
p = "is" # 찾을 패턴
t= "This is a book~!" # 전체 텍스트
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이

def BruteForce(p, t):
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i - j
            j = -1
        i = i + 1
        j = j + 1
    if j == M:
        return i-M # 검색 성공
    else:
        return -1 # 검색 실패
```

- 시간 복잡도: 최악의 경우, 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)



## KMP 알고리즘

불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행.

1. 문자 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함.
2. next[M]은 불일치가 발생했을 경우 이동할 다음 위치를 저장.

```python
def KMPSearch(pat, txt):
    M = len(pat)
    N = len(txt)

    next = [0]*M

    # Preprocess the pattern
    computeLPS(pat, next)

    i = 0  # index for txt[]
    j = 0  # index for pat[]
    while i < N:
        # 문자열이 같은 경우 양쪽 인덱스를 모두 증가시킴
        if pat[j] == txt[i]:
            i += 1
            j += 1
        # Pattern을 찾지 못한 경우
        elif pat[j] != txt[i]:
            # j!=0인 경우는 짧은 lps에 대해 재검사
            if j != 0:
                j = next[j-1]
            # j==0이면 일치하는 부분이 없으므로 인덱스 증가
            else:
                i += 1

        # Pattern을 찾은 경우
        if j == M:
            print("Found pattern at index " + str(i-j))
            # 이전 인덱스의 next값을 참조하여 계속 검색
            j = next[j-1]

def computeLPS(pat, lps):
    leng = 0  # length of the previous longest prefix suffix

    # 항상 next[0]==0이므로 while문은 i==1부터 시작한다.
    i = 1
    while i < len(pat):
        # 이전 인덱스에서 같았다면 다음 인덱스만 비교하면 된다.
        if pat[i] == pat[leng]:
            leng += 1
            next[i] = leng
            i += 1
        else:
            # 일치하지 않는 경우
            if leng != 0:
                # 이전 인덱스에서는 같았으므로 leng을 줄여서 다시 검사
                leng = next[leng-1]
                # 다시 검사해야 하므로 i는 증가하지 않음
            else:
                # 이전 인덱스에서도 같지 않았다면 next[i]는 0 이고 i는 1 증가
                next[i] = 0
                i += 1

# 조금 더 긴 텍스트
# txt = "ABABDABACDABABCABAB"
# pat = "ABABCABAB"
# 본문에서 다룬 예제
txt = 'ABXABABXAB'
pat = 'ABXAB'
KMPSearch(pat, txt)

# This code is contributed by Bhavya Jain
```

코드 출처 - [일시불 프로그래밍 - [Python] KMP 알고리즘으로 문자열 찾기](https://devbull.xyz/python-kmp-algorijeumeuro-munjayeol-cajgi/)

- 시간 복잡도: O(M+N)



## 보이어-무어 알고리즘

오른쪽에서 왼쪽으로 비교.

- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘.
- 패턴에 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 패턴의 길이만큼이 됨.

- 시간 복잡도: O(N) 보다 작음.

```python
def boyer_moore(pattern, text):
    #길이를 자주쓰므로 길이를 받아둔다.
    M = len(pattern)
    N = len(text)
    i = 0
    #반복은 최대 긴텍스트 길이 - 작은텍스트 길이
    while i <= N-M:
        #보이어 무어 알고리즘은 뒤에서부터 접근하므로 pattern길이의 -1을 해준다.
        #-1을 해주는 이유는 인덱스가 0부터 시작하기 때문이다.
        j = M - 1
        #뒤에서부터 검사하고 인덱스를 감소하는 형식이므로 0보다 이상일때만 동작한다.
        while j >= 0:
            #끝글자부터 비교하면서 같다면 하나씩 감소하면서 비교한다.
            if pattern[j] != text[i+j]:
                #글자가 틀리다면 제일마지막 글자 기준으로 find 함수를 호출한다.
               move = find(pattern, text[i + M - 1])
                break
            j = j - 1
        #인덱스가 -1이라는 뜻은 모든 글자가 맞았다는 이야기이다.
        if j == -1:
            return i
        else:
            #-1이 아니라면 글자를 못찾은 것이므로 find에서 넘겨준 값만큼 옆으로 이동한다.
            i += move
    return -1

def find(pattern, char):
    #마지막 부분과 일치하는 부분이 있는지 검색한다.
    #마지막 부분은 이미 가능성이 없으므로 그전부터 검사한다.
    for i in range(len(pattern)-2, -1, -1):
        #마지막글자와 패턴중 일치하는 숫자가 있다면 그만큼 이동한다.
        if pattern[i] == char:
            return len(pattern) -i -1
    #일치하는 글자가 없다면 패턴의 길이만큼 이동한다.
    return len(pattern)
```

코드 출처 - [멍토의 IT 블로그 - 보이어-무어 알고리즘(문자열 검색, Python)](https://mungto.tistory.com/124)


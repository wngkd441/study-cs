# 4. Binary Search Tree

### Binary Search Tree의 특징

- 탐색작업을 효율적으로 하기 위한 자료구조.
- 모든 원소는 서로 다른 유일한 키를 가짐.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리) 로 배치.
- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리임.
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음.



## Binary Search Tree의 연산

### 탐색 연산

1. 루트에서 시작
2. 탐색할 키 값 x를 루트 노드의 키 값과 비교.
   - 같을 경우, 탐색 연산 성공.
   - 키 값 < 루트 노드의 키 값일 경우, 루트 노드의 왼쪽 서브트리에 대해서 탐색 연산 수행.
   - 키 값 > 루트 노드의 키 값일 경우, 루트 노드의 오른쪽 서브트리에 대해서 탐색 연산 수행.
3. 서브 트리에 대해서 순환적으로 탐색 연산을 반복.



### 삽입 연산

1. 먼저 탐색 연산을 수행.
   - 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인.
   - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 됨.
2. 탐색 실패한 위치에 원소를 삽입.





## Binary Search Tree의 성능

- 탐색(Searching), 삽입(Insertion), 삭제(Deletion) 시간은 트리의 높이에 좌우됨.
  - 높이가 h인 이진 탐색 트리의 시간 복잡도 = O(h)
- 이진 트리가 균형적으로 생성되어 있는 경우, 시간 복잡도 = O(logn)
- (최악의 경우) 한 쪽으로 치우저니 경사 이진 트리의 경우, 시간 복잡도 = O(n)



### 검색 알고리즘의 비교

- 리스트에서의 순차 검색: O(n)
- 정렬된 리스트에서의 순차 검색: O(n)
- 정렬된 리스트에서의 이진 검색: O(logn)
- 이진 탐색 트리에서의 평균: O(logn)
- 이진 탐색 트리에서의 최악: O(n)
  - 이진 트리를 완전 이진 트리 또는 균형 트리로 바꿀 수 있다면 최악의 경우를 없앨 수 있음.
- 해쉬 검색: O(1)
  - 데이터를 저장할 추가공간이 필요.


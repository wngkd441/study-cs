# 3. 분할 정복



## 분할 정복 알고리즘

### 설계 전략

- 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눔.
- 정복(Conquer): 나눈 작은 문제를 각각 해결.
- 통합(Combine): 해결된 해답을 모음.



### 거듭제곱(Exponentiation) 알고리즘

```python
def Power(Base, Exponent):
    if Base == 0:
        return 1
    result = 1 # Base^0 = 1 이므로
    for i in range(Exponent):
        result *= Base
    return result
```

n번의 곱셉을 수행하므로 시간복잡도 = O(n)



### 분할 정복 기반의 알고리즘

```python
def Power(Base, Exponent):
    if Exponent == 0 or Base == 0:
        return 1
   	if Exponent % 2 == 0:
        NewBase = Power(Base, Exponent/2)
        return NewBase * NewBase
    else:
        NewBase = Power(Base, (Exponent-1)/2)
        return (NewBase * NewBase) * Base
```

시간복잡도 = O(log2n)





## 퀵 정렬

### 퀵 정렬과 합병 정렬의 비교

|        |                        합병 정렬                        |                           퀵 정렬                            |
| :----: | :-----------------------------------------------------: | :----------------------------------------------------------: |
| 공통점 |       주어진 리스트를 두 개로 분할하고, 각각 정렬       |         주어진 리스트를 두 개로 분할하고, 각각 정렬          |
| 차이점 |          분할할 때, 단순하게 두 부분으로 나눔           | 분할할 때, 기준 아이템(Pivot item)을 중심으로, 작은 것은 왼편, 큰 것은 오른편에 위치시킴 |
| 차이점 | 각 부분 정렬이 끝난 후, '합병'이란 후처리 작업이 필요함 |     각 부분 정렬이 끝난 후, 후처리 작업이 필요하지 않음      |



### 퀵 정렬 알고리즘

```python
def quickSort(a, begin, end):
    if begin < end:
        p = partition(a, begin, end) # Pivot을 구함
        quickSort(a, begin, p-1) # Pivot보다 작은 값을 퀵 정렬
        quickSort(a, p+1, end) # Pivot보다 큰 값을 퀵 정렬
```



### 주어진 리스트에서 Pivot을 구하는 알고리즘

```python
def partition(a, begin, end):
    pivot = (begin + end) // 2
    L = begin
    R = end
    while L < R:
        while(a[L] < a[pivot] and L < R):
            L += 1
        while(a[R] >= a[pivot] and L < R):
            R -= 1
        if L < R:
            if L == pivot:
                pivot = R
            a[L], a[R] = a[R], a[L]
    a[pivot], a[R] = a[R], a[pivot]
    return R
```



- 퀵 정렬의 최악의 시간 복잡도는 O(n^2)이지만 평균 복잡도는 nlogn이다.
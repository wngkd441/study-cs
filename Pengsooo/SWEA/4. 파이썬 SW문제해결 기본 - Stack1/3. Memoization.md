# 3. Memoization



## 피보나치 수열

0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열

- 피보나치 수열의 i번째 값 정의

  `F_0 = 0, F_1 = 1`

  `F_i = F_i-1 + F_i-2 for i>=2`

  위의 정의로부터 피보나치 수열의 i번째 항을 반환하는 함수를 재귀 함수로 구현할 수 있음.



## 피보나치 수를 구하는 재귀 함수

### 피보나치 수열을 구하는 함수의 알고리즘

```python
def fibo(n):
    if n < 2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)
```

- 문제점: 엄청난 중복 호출이 존재.



### 피보나치 수열의 재귀 함수 Call Tree

같은 입력값에 대한 함수 호출이 많이 중복되었음을 확인할 수 있음.



## Memoization

**Memoization** : 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록하여 전체적인 실행속도를 빠르게 하는 기술.

- DP(동적 계획법)의 핵심이 되는 기술.
- 글자 그대로 해석하면 '메모리에 넣기(to put in memory)'.



### Memoization 방법을 적용한 피보나치 수열을 구하는 알고리즘

- 피보나치 수를 구하는 알고리즘에서 `fibo(n)`의 값을 계산하자마자 저장하면 실행시간을 줄일 수 있음.
- 만약 기존에 계산하여 저장된 값이 있을 경우에는 다시 계산하지 않겠다는 알고리즘.

```python
# memo를 위한 리스트를 생성하고, memo[0]을 0으로 memo[1]을 1로 초기화한다.

def fibo1(n):
    global memo
    if n>=2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0, 1]
```